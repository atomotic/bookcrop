<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Page Viewer - Margin Selector</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        .header {
            padding: 12px 20px;
            background: #2a2a2a;
            border-bottom: 1px solid #3a3a3a;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        button {
            padding: 8px 16px;
            background: #4a4a4a;
            color: #e0e0e0;
            border: 1px solid #5a5a5a;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        button:hover:not(:disabled) {
            background: #5a5a5a;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.active {
            background: #0066cc;
            border-color: #0077ee;
        }

        button.active:hover {
            background: #0077ee;
        }

        .info {
            font-size: 14px;
            color: #a0a0a0;
        }

        .coordinates {
            font-size: 13px;
            color: #6c9;
            font-family: monospace;
            padding: 4px 8px;
            background: #2a2a2a;
            border-radius: 3px;
        }

        .image-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow: auto;
            position: relative;
        }

        .image-wrapper {
            position: relative;
            display: inline-block;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .image-wrapper img {
            display: block;
            max-width: 100%;
            max-height: calc(100vh - 200px);
            object-fit: contain;
        }

        .image-wrapper canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
        }

        .placeholder {
            text-align: center;
            color: #666;
            font-size: 16px;
        }

        .controls {
            padding: 12px 20px;
            background: #2a2a2a;
            border-top: 1px solid #3a3a3a;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .controls button {
            min-width: 80px;
        }

        .page-indicators {
            padding: 8px 20px;
            background: #2a2a2a;
            border-top: 1px solid #3a3a3a;
            display: flex;
            justify-content: center;
            gap: 4px;
            flex-wrap: wrap;
            max-height: 80px;
            overflow-y: auto;
        }

        .page-indicator {
            width: 8px;
            height: 28px;
            background: #4a4a4a;
            border: 1px solid #5a5a5a;
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .page-indicator:hover {
            background: #5a5a5a;
            transform: scaleY(1.1);
        }

        .page-indicator.has-selection {
            background: #6c9;
            border-color: #7da;
        }

        .page-indicator.current {
            background: #0066cc;
            border-color: #0077ee;
            border-width: 2px;
            transform: scaleY(1.15);
        }

        .page-indicator.current.has-selection {
            background: linear-gradient(to right, #0066cc 50%, #6c9 50%);
        }

        .page-indicator::after {
            content: attr(data-page);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            margin-bottom: 4px;
        }

        .page-indicator:hover::after {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="header">
        <button id="selectBtn">Select Directory</button>
        <div class="info" id="info">No directory selected</div>
        <button id="lockBtn" disabled>Lock Selection</button>
        <button id="exportBtn" disabled>Export CSV</button>
        <button id="exportVipsBtn" disabled>Export VIPS Script</button>
        <div class="coordinates" id="coordinates">No selection</div>
    </div>

    <div class="image-container" id="imageContainer">
        <div class="placeholder">Select a directory to begin</div>
    </div>

    <div class="controls">
        <button id="prevBtn" disabled>Previous</button>
        <button id="nextBtn" disabled>Next</button>
    </div>

    <div class="page-indicators" id="pageIndicators"></div>

    <script>
        let directoryHandle = null;
        let directoryName = null;
        let imageFiles = [];
        let currentIndex = 0;
        let allSelections = {}; // directoryName -> { pageId -> {ulx, uly, lrx, lry} }
        let selections = {}; // current directory's selections: pageId -> {ulx, uly, lrx, lry}
        let isLocked = false;

        // Selection state
        let selection = null; // {ulx, uly, lrx, lry}
        let isDrawing = false;
        let isDragging = false;
        let isResizing = false;
        let dragStart = null;
        let resizeHandle = null; // 'nw', 'ne', 'sw', 'se', or null

        const selectBtn = document.getElementById('selectBtn');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const lockBtn = document.getElementById('lockBtn');
        const exportBtn = document.getElementById('exportBtn');
        const exportVipsBtn = document.getElementById('exportVipsBtn');
        const info = document.getElementById('info');
        const coordinates = document.getElementById('coordinates');
        const imageContainer = document.getElementById('imageContainer');
        const pageIndicators = document.getElementById('pageIndicators');

        const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.tif', '.tiff'];
        const STORAGE_KEY = 'page-selections';
        const HANDLE_SIZE = 10;

        // Load all selections from localStorage
        function loadAllSelectionsFromStorage() {
            const stored = localStorage.getItem(STORAGE_KEY);
            if (stored) {
                try {
                    allSelections = JSON.parse(stored);
                } catch (e) {
                    console.error('Error loading selections:', e);
                    allSelections = {};
                }
            }
        }

        // Save all selections to localStorage
        function saveAllSelectionsToStorage() {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(allSelections));
        }

        // Load selections for current directory
        function loadSelectionsForDirectory() {
            if (directoryName && allSelections[directoryName]) {
                selections = allSelections[directoryName];
            } else {
                selections = {};
            }
        }

        // Save current directory's selections
        function saveSelectionsForDirectory() {
            if (directoryName) {
                allSelections[directoryName] = selections;
                saveAllSelectionsToStorage();
            }
        }

        loadAllSelectionsFromStorage();

        selectBtn.addEventListener('click', async () => {
            try {
                directoryHandle = await window.showDirectoryPicker();
                directoryName = directoryHandle.name;
                loadSelectionsForDirectory();
                await loadImages();
            } catch (err) {
                if (err.name !== 'AbortError') {
                    console.error('Error selecting directory:', err);
                    alert('Error selecting directory: ' + err.message);
                }
            }
        });

        prevBtn.addEventListener('click', () => {
            if (currentIndex > 0) {
                saveCurrentSelection();
                currentIndex--;
                displayImage();
            }
        });

        nextBtn.addEventListener('click', () => {
            if (currentIndex < imageFiles.length - 1) {
                saveCurrentSelection();
                currentIndex++;
                displayImage();
            }
        });

        lockBtn.addEventListener('click', () => {
            isLocked = !isLocked;
            lockBtn.textContent = isLocked ? 'Unlock Selection' : 'Lock Selection';
            lockBtn.classList.toggle('active', isLocked);
        });

        exportBtn.addEventListener('click', () => {
            exportToCSV();
        });

        exportVipsBtn.addEventListener('click', () => {
            exportVipsScript();
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' && !prevBtn.disabled) {
                prevBtn.click();
            } else if (e.key === 'ArrowRight' && !nextBtn.disabled) {
                nextBtn.click();
            }
        });

        async function loadImages() {
            imageFiles = [];

            for await (const entry of directoryHandle.values()) {
                if (entry.kind === 'file') {
                    const ext = '.' + entry.name.split('.').pop().toLowerCase();
                    if (imageExtensions.includes(ext)) {
                        imageFiles.push(entry);
                    }
                }
            }

            imageFiles.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true }));

            if (imageFiles.length === 0) {
                info.textContent = 'No images found in directory';
                imageContainer.innerHTML = '<div class="placeholder">No images found</div>';
                prevBtn.disabled = true;
                nextBtn.disabled = true;
                return;
            }

            currentIndex = 0;
            exportBtn.disabled = false;
            exportVipsBtn.disabled = false;
            renderPageIndicators();
            displayImage();
        }

        async function displayImage() {
            if (imageFiles.length === 0) return;

            const fileHandle = imageFiles[currentIndex];
            const file = await fileHandle.getFile();
            const url = URL.createObjectURL(file);

            // Create image wrapper with canvas overlay
            const wrapper = document.createElement('div');
            wrapper.className = 'image-wrapper';

            const img = document.createElement('img');
            img.src = url;
            img.alt = fileHandle.name;

            const canvas = document.createElement('canvas');

            wrapper.appendChild(img);
            wrapper.appendChild(canvas);
            imageContainer.innerHTML = '';
            imageContainer.appendChild(wrapper);

            img.onload = () => {
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                canvas.style.width = img.clientWidth + 'px';
                canvas.style.height = img.clientHeight + 'px';

                setupCanvasEvents(canvas, img);
                loadCurrentSelection();
                drawSelection(canvas);
            };

            info.textContent = `[${directoryName}] ${currentIndex + 1} / ${imageFiles.length} - ${fileHandle.name}`;
            lockBtn.disabled = false;
            prevBtn.disabled = currentIndex === 0;
            nextBtn.disabled = currentIndex === imageFiles.length - 1;
            updatePageIndicators();
        }

        function getCurrentPageId() {
            return imageFiles[currentIndex]?.name || null;
        }

        function saveCurrentSelection() {
            const pageId = getCurrentPageId();
            if (pageId && selection) {
                selections[pageId] = { ...selection };
                saveSelectionsForDirectory();
                updatePageIndicators();
            }
        }

        function loadCurrentSelection() {
            const pageId = getCurrentPageId();
            if (pageId && selections[pageId]) {
                selection = { ...selections[pageId] };
            }
            updateCoordinatesDisplay();
        }

        function renderPageIndicators() {
            pageIndicators.innerHTML = '';

            imageFiles.forEach((file, index) => {
                const indicator = document.createElement('div');
                indicator.className = 'page-indicator';
                indicator.dataset.page = `${index + 1}: ${file.name}`;
                indicator.dataset.index = index;

                if (selections[file.name]) {
                    indicator.classList.add('has-selection');
                }

                if (index === currentIndex) {
                    indicator.classList.add('current');
                }

                indicator.addEventListener('click', () => {
                    if (currentIndex !== index) {
                        saveCurrentSelection();
                        currentIndex = index;
                        displayImage();
                    }
                });

                pageIndicators.appendChild(indicator);
            });
        }

        function updatePageIndicators() {
            const indicators = pageIndicators.querySelectorAll('.page-indicator');
            indicators.forEach((indicator, index) => {
                const fileName = imageFiles[index].name;

                indicator.classList.toggle('has-selection', !!selections[fileName]);
                indicator.classList.toggle('current', index === currentIndex);
            });
        }

        function setupCanvasEvents(canvas, img) {
            const getMousePos = (e) => {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            };

            const getResizeHandle = (pos) => {
                if (!selection) return null;
                const threshold = HANDLE_SIZE;

                const nearUL = Math.abs(pos.x - selection.ulx) < threshold && Math.abs(pos.y - selection.uly) < threshold;
                const nearUR = Math.abs(pos.x - selection.lrx) < threshold && Math.abs(pos.y - selection.uly) < threshold;
                const nearLL = Math.abs(pos.x - selection.ulx) < threshold && Math.abs(pos.y - selection.lry) < threshold;
                const nearLR = Math.abs(pos.x - selection.lrx) < threshold && Math.abs(pos.y - selection.lry) < threshold;

                if (nearUL) return 'nw';
                if (nearUR) return 'ne';
                if (nearLL) return 'sw';
                if (nearLR) return 'se';
                return null;
            };

            const isInsideSelection = (pos) => {
                if (!selection) return false;
                return pos.x >= selection.ulx && pos.x <= selection.lrx &&
                       pos.y >= selection.uly && pos.y <= selection.lry;
            };

            canvas.addEventListener('mousedown', (e) => {
                const pos = getMousePos(e);

                if (selection) {
                    const handle = getResizeHandle(pos);
                    if (handle && !isLocked) {
                        isResizing = true;
                        resizeHandle = handle;
                        return;
                    }

                    if (isInsideSelection(pos)) {
                        isDragging = true;
                        dragStart = { x: pos.x - selection.ulx, y: pos.y - selection.uly };
                        return;
                    }

                    // When locked, don't allow drawing a new selection
                    if (isLocked) {
                        return;
                    }
                }

                // Start new selection
                isDrawing = true;
                selection = { ulx: pos.x, uly: pos.y, lrx: pos.x, lry: pos.y };
                drawSelection(canvas);
            });

            canvas.addEventListener('mousemove', (e) => {
                const pos = getMousePos(e);

                if (isDrawing) {
                    selection.lrx = pos.x;
                    selection.lry = pos.y;
                    drawSelection(canvas);
                    updateCoordinatesDisplay();
                } else if (isDragging && selection) {
                    const width = selection.lrx - selection.ulx;
                    const height = selection.lry - selection.uly;
                    selection.ulx = Math.max(0, Math.min(canvas.width - width, pos.x - dragStart.x));
                    selection.uly = Math.max(0, Math.min(canvas.height - height, pos.y - dragStart.y));
                    selection.lrx = selection.ulx + width;
                    selection.lry = selection.uly + height;
                    drawSelection(canvas);
                    updateCoordinatesDisplay();
                } else if (isResizing && selection && !isLocked) {
                    const { ulx, uly, lrx, lry } = selection;

                    switch (resizeHandle) {
                        case 'nw':
                            selection.ulx = Math.min(pos.x, lrx - 10);
                            selection.uly = Math.min(pos.y, lry - 10);
                            break;
                        case 'ne':
                            selection.lrx = Math.max(pos.x, ulx + 10);
                            selection.uly = Math.min(pos.y, lry - 10);
                            break;
                        case 'sw':
                            selection.ulx = Math.min(pos.x, lrx - 10);
                            selection.lry = Math.max(pos.y, uly + 10);
                            break;
                        case 'se':
                            selection.lrx = Math.max(pos.x, ulx + 10);
                            selection.lry = Math.max(pos.y, uly + 10);
                            break;
                    }

                    drawSelection(canvas);
                    updateCoordinatesDisplay();
                } else {
                    // Update cursor
                    if (selection) {
                        const handle = getResizeHandle(pos);
                        if (handle && !isLocked) {
                            const cursors = { nw: 'nw-resize', ne: 'ne-resize', sw: 'sw-resize', se: 'se-resize' };
                            canvas.style.cursor = cursors[handle];
                        } else if (isInsideSelection(pos)) {
                            canvas.style.cursor = 'move';
                        } else {
                            canvas.style.cursor = 'crosshair';
                        }
                    }
                }
            });

            canvas.addEventListener('mouseup', () => {
                if (isDrawing || isDragging || isResizing) {
                    normalizeSelection();
                    saveCurrentSelection();
                }
                isDrawing = false;
                isDragging = false;
                isResizing = false;
                resizeHandle = null;
                dragStart = null;
            });

            canvas.addEventListener('mouseleave', () => {
                if (isDrawing || isDragging || isResizing) {
                    normalizeSelection();
                    saveCurrentSelection();
                }
                isDrawing = false;
                isDragging = false;
                isResizing = false;
                resizeHandle = null;
            });
        }

        function normalizeSelection() {
            if (!selection) return;
            const { ulx, uly, lrx, lry } = selection;
            selection.ulx = Math.round(Math.min(ulx, lrx));
            selection.uly = Math.round(Math.min(uly, lry));
            selection.lrx = Math.round(Math.max(ulx, lrx));
            selection.lry = Math.round(Math.max(uly, lry));
        }

        function drawSelection(canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!selection) return;

            const { ulx, uly, lrx, lry } = selection;
            const width = lrx - ulx;
            const height = lry - uly;

            // Draw semi-transparent overlay outside selection
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, uly);
            ctx.fillRect(0, uly, ulx, height);
            ctx.fillRect(lrx, uly, canvas.width - lrx, height);
            ctx.fillRect(0, lry, canvas.width, canvas.height - lry);

            // Draw selection border
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 2;
            ctx.strokeRect(ulx, uly, width, height);

            // Draw corner handles
            if (!isLocked) {
                ctx.fillStyle = '#0f0';
                const corners = [
                    [ulx, uly], [lrx, uly],
                    [ulx, lry], [lrx, lry]
                ];
                corners.forEach(([x, y]) => {
                    ctx.fillRect(x - HANDLE_SIZE/2, y - HANDLE_SIZE/2, HANDLE_SIZE, HANDLE_SIZE);
                });
            }
        }

        function updateCoordinatesDisplay() {
            if (selection) {
                normalizeSelection();
                coordinates.textContent =
                    `UL(${selection.ulx}, ${selection.uly}) LR(${selection.lrx}, ${selection.lry})`;
            } else {
                coordinates.textContent = 'No selection';
            }
        }

        function exportToCSV() {
            if (Object.keys(selections).length === 0) {
                alert('No selections to export');
                return;
            }

            let csv = 'filename,ulx,uly,lrx,lry\n';

            for (const [pageId, sel] of Object.entries(selections)) {
                csv += `${pageId},${sel.ulx},${sel.uly},${sel.lrx},${sel.lry}\n`;
            }

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${directoryName}-selections.csv`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportVipsScript() {
            if (Object.keys(selections).length === 0) {
                alert('No selections to export');
                return;
            }

            let script = '#!/bin/bash\n\n';
            script += '# VIPS image cropping script\n';
            script += `# Generated from page-viewer selections for: ${directoryName}\n\n`;
            script += 'mkdir -p cropped\n\n';

            for (const [pageId, sel] of Object.entries(selections)) {
                const width = sel.lrx - sel.ulx;
                const height = sel.lry - sel.uly;
                script += `vips extract_area "${pageId}" "cropped/${pageId}" ${sel.ulx} ${sel.uly} ${width} ${height}\n`;
            }

            script += '\necho "Cropping complete!"\n';

            const blob = new Blob([script], { type: 'text/x-shellscript' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${directoryName}-crop.sh`;
            a.click();
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
